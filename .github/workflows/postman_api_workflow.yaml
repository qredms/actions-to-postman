name: Generate and Push Postman Collection via API

on:
  push:
    branches:
      - main
    paths:
      - 'cloudformation/openapi.yaml'
      - '.github/workflows/postman_api_workflow.yaml'
  workflow_dispatch:

jobs:
  generate_and_push_collection:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Validate OpenAPI file
        run: |
          INPUT_OAS_FILE="cloudformation/openapi.yaml"
          
          # Check if file exists
          if [ ! -f "$INPUT_OAS_FILE" ]; then
            echo "Error: OpenAPI file not found at $INPUT_OAS_FILE"
            ls -la cloudformation/
            exit 1
          fi
          
          # Check file size
          FILE_SIZE=$(stat -c%s "$INPUT_OAS_FILE")
          echo "OpenAPI file size: $FILE_SIZE bytes"
          
          # Show file content (first 20 lines)
          echo "OpenAPI file content (first 20 lines):"
          head -n 20 "$INPUT_OAS_FILE"

      - name: Install openapi-to-postmanv2
        run: npm install -g openapi-to-postmanv2

      - name: Generate Postman Collection
        id: generate_collection
        run: |
          INPUT_OAS_FILE="cloudformation/openapi.yaml"
          OUTPUT_COLLECTION_FILE="postman_collection.json"
          
          echo "Running OpenAPI to Postman conversion..."
          openapi2postmanv2 -s "${INPUT_OAS_FILE}" -o "${OUTPUT_COLLECTION_FILE}" -p
          
          # Check if conversion was successful
          if [ ! -f "$OUTPUT_COLLECTION_FILE" ]; then
            echo "Error: Conversion failed to generate output file"
            echo "Listing contents of current directory to debug:"
            ls -la
            exit 1
          fi
          
          # Check generated file size
          FILE_SIZE=$(stat -c%s "$OUTPUT_COLLECTION_FILE")
          echo "Generated collection file size: $FILE_SIZE bytes"
          
          # Validate the JSON format
          if ! jq empty "$OUTPUT_COLLECTION_FILE" 2>/dev/null; then
            echo "Error: Generated collection is not valid JSON!"
            echo "First 100 characters of the file:"
            head -c 100 "$OUTPUT_COLLECTION_FILE"
            exit 1
          fi
          
          echo "collection_file=${OUTPUT_COLLECTION_FILE}" >> $GITHUB_OUTPUT

      - name: Prepare Collection JSON for API Request
        id: prepare_collection
        run: |
          COLLECTION_FILE=${{ steps.generate_collection.outputs.collection_file }}
          
          # Make sure the file exists
          if [ ! -f "$COLLECTION_FILE" ]; then
            echo "Error: Collection file not found at $COLLECTION_FILE"
            exit 1
          fi
          
          # Format the collection JSON to comply with Postman API requirements
          # Postman API expects the collection to be wrapped in a "collection" key
          jq '{"collection": .}' "$COLLECTION_FILE" > "postman_api_payload.json"
          
          # Validate the resulting JSON
          if ! jq empty "postman_api_payload.json" 2>/dev/null; then
            echo "Error: API payload is not valid JSON!"
            exit 1
          fi
          
          echo "api_payload_file=postman_api_payload.json" >> $GITHUB_OUTPUT

      - name: Update Existing Collection via API
        id: update_collection
        env:
          POSTMAN_API_KEY: ${{ secrets.POSTMAN_API_KEY }}
          POSTMAN_COLLECTION_UID: ${{ secrets.POSTMAN_COLLECTION_UID }}
          API_PAYLOAD_FILE: ${{ steps.prepare_collection.outputs.api_payload_file }}
        run: |
          # Validate required secrets
          if [ -z "$POSTMAN_API_KEY" ]; then
            echo "Error: POSTMAN_API_KEY secret is not set"
            exit 1
          fi
          
          if [ -z "$POSTMAN_COLLECTION_UID" ]; then
            echo "Error: POSTMAN_COLLECTION_UID secret is not set"
            exit 1
          fi
          
          echo "Collection UID: $POSTMAN_COLLECTION_UID"
          
          # Verify API payload file exists
          if [ ! -f "$API_PAYLOAD_FILE" ]; then
            echo "Error: API payload file does not exist at $API_PAYLOAD_FILE"
            ls -la
            exit 1
          fi
          
          # Show API payload file size
          FILE_SIZE=$(stat -c%s "$API_PAYLOAD_FILE")
          echo "API payload file size: $FILE_SIZE bytes"
          
          # API endpoint for updating a collection
          API_URL="https://api.getpostman.com/collections/$POSTMAN_COLLECTION_UID"
          
          echo "Updating collection via API at: $API_URL"
          
          # Create a compact version of the JSON payload for curl
          JSON_PAYLOAD=$(jq -c . "$API_PAYLOAD_FILE")
          
          # Update collection via API
          response=$(curl --location --request PUT "$API_URL" \
            --header "X-Api-Key: $POSTMAN_API_KEY" \
            --header "Content-Type: application/json" \
            --data "$JSON_PAYLOAD" \
            --silent --write-out "HTTPSTATUS:%{http_code}")
            
          # Extract HTTP status
          http_status=$(echo "$response" | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
          # Extract body
          body=$(echo "$response" | sed -e 's/HTTPSTATUS:.*//')
          
          echo "Response Body: $body"
          echo "HTTP Status: $http_status"
          
          if [ "$http_status" -eq 200 ] || [ "$http_status" -eq 201 ]; then
            echo "Postman collection updated successfully."
            
            # Extract and store the collection UID from response if needed
            collection_uid=$(echo "$body" | jq -r '.collection.uid')
            echo "Collection UID: $collection_uid"
            echo "collection_uid=$collection_uid" >> $GITHUB_OUTPUT
          else
            echo "Error updating Postman collection. Status: $http_status"
            exit 1
          fi

      - name: Create New Collection if Update Failed
        id: create_collection
        if: ${{ failure() && steps.update_collection.conclusion == 'failure' }}
        env:
          POSTMAN_API_KEY: ${{ secrets.POSTMAN_API_KEY }}
          POSTMAN_WORKSPACE_ID: ${{ secrets.POSTMAN_WORKSPACE_ID }}
          API_PAYLOAD_FILE: ${{ steps.prepare_collection.outputs.api_payload_file }}
        run: |
          # Validate required secrets
          if [ -z "$POSTMAN_API_KEY" ]; then
            echo "Error: POSTMAN_API_KEY secret is not set"
            exit 1
          fi
          
          if [ -z "$POSTMAN_WORKSPACE_ID" ]; then
            echo "Error: POSTMAN_WORKSPACE_ID secret is not set"
            exit 1
          fi
          
          echo "Workspace ID: $POSTMAN_WORKSPACE_ID"
          
          # Verify API payload file exists
          if [ ! -f "$API_PAYLOAD_FILE" ]; then
            echo "Error: API payload file does not exist at $API_PAYLOAD_FILE"
            ls -la
            exit 1
          fi
          
          # API endpoint for creating a collection within a workspace
          API_URL="https://api.getpostman.com/collections?workspace=$POSTMAN_WORKSPACE_ID"
          
          echo "Creating new collection via API at: $API_URL"
          
          # Create a compact version of the JSON payload for curl
          JSON_PAYLOAD=$(jq -c . "$API_PAYLOAD_FILE")
          
          # Create collection via API
          response=$(curl --location --request POST "$API_URL" \
            --header "X-Api-Key: $POSTMAN_API_KEY" \
            --header "Content-Type: application/json" \
            --data "$JSON_PAYLOAD" \
            --silent --write-out "HTTPSTATUS:%{http_code}")
            
          # Extract HTTP status
          http_status=$(echo "$response" | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
          # Extract body
          body=$(echo "$response" | sed -e 's/HTTPSTATUS:.*//')
          
          echo "Response Body: $body"
          echo "HTTP Status: $http_status"
          
          if [ "$http_status" -eq 200 ] || [ "$http_status" -eq 201 ]; then
            echo "New Postman collection created successfully."
            
            # Extract and store the collection UID from response
            collection_uid=$(echo "$body" | jq -r '.collection.uid')
            echo "New Collection UID: $collection_uid"
            echo "collection_uid=$collection_uid" >> $GITHUB_OUTPUT
            
            echo "============================================="
            echo "IMPORTANT: Update your POSTMAN_COLLECTION_UID repository secret with the new UID: $collection_uid"
            echo "============================================="
          else
            echo "Error creating Postman collection. Status: $http_status"
            exit 1
          fi

      - name: Upload Postman Collection as Artifact
        uses: actions/upload-artifact@v4
        with:
          name: postman-collection
          path: ${{ steps.generate_collection.outputs.collection_file }}
          retention-days: 7