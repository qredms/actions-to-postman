name: Generate and Push Postman Collection

on:
  push:
    branches:
      - main
    paths:
      - 'cloudformation/openapi.yaml'
      - '.github/workflows/push_to_postman.yaml'
  workflow_dispatch:

jobs:
  generate_and_push_collection:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Validate OpenAPI file
        run: |
          INPUT_OAS_FILE="cloudformation/openapi.yaml"
          
          # Check if file exists
          if [ ! -f "$INPUT_OAS_FILE" ]; then
            echo "Error: OpenAPI file not found at $INPUT_OAS_FILE"
            ls -la cloudformation/
            exit 1
          fi
          
          # Check file size
          FILE_SIZE=$(stat -c%s "$INPUT_OAS_FILE")
          echo "OpenAPI file size: $FILE_SIZE bytes"
          
          # Show file content (first 100 lines)
          echo "OpenAPI file content (first 100 lines):"
          head -n 100 "$INPUT_OAS_FILE"

      - name: Install openapi-to-postmanv2
        run: npm install -g openapi-to-postmanv2

      - name: Test OpenAPI conversion
        id: generate_collection
        run: |
          INPUT_OAS_FILE="cloudformation/openapi.yaml"
          OUTPUT_COLLECTION_FILE="postman_collection.json"
          
          # Run conversion with debug output
          echo "Running OpenAPI to Postman conversion..."
          openapi2postmanv2 -s "${INPUT_OAS_FILE}" -o "${OUTPUT_COLLECTION_FILE}" -p -d
          
          # Check if conversion was successful
          if [ ! -f "$OUTPUT_COLLECTION_FILE" ]; then
            echo "Error: Conversion failed to generate output file"
            exit 1
          fi
          
          # Check generated file size
          FILE_SIZE=$(stat -c%s "$OUTPUT_COLLECTION_FILE")
          echo "Generated collection file size: $FILE_SIZE bytes"
          
          # Validate the collection structure
          if [ "$FILE_SIZE" -lt 100 ]; then
            echo "Warning: Generated collection file is suspiciously small"
          fi
          
          # Check if the collection has items
          ITEM_COUNT=$(jq '.item | length' "$OUTPUT_COLLECTION_FILE")
          echo "Collection item count: $ITEM_COUNT"
          
          if [ "$ITEM_COUNT" -eq 0 ]; then
            echo "Warning: Generated collection has no items (endpoints)"
            
            # Inspect full content for small collections
            if [ "$FILE_SIZE" -lt 5000 ]; then
              echo "Full collection content:"
              cat "$OUTPUT_COLLECTION_FILE"
            else
              echo "Collection structure:"
              jq '.info, .item | length' "$OUTPUT_COLLECTION_FILE"
            fi
          fi
          
          echo "collection_file=${OUTPUT_COLLECTION_FILE}" >> $GITHUB_OUTPUT

      - name: Create sample collection if needed
        run: |
          OUTPUT_COLLECTION_FILE="postman_collection.json"
          ITEM_COUNT=$(jq '.item | length' "$OUTPUT_COLLECTION_FILE")
          
          if [ "$ITEM_COUNT" -eq 0 ]; then
            echo "Creating a sample collection with test endpoints..."
            cat > "$OUTPUT_COLLECTION_FILE" << EOL
          {
            "info": {
              "name": "API Collection",
              "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
            },
            "item": [
              {
                "name": "Test Endpoint",
                "request": {
                  "method": "GET",
                  "url": {
                    "raw": "https://example.com/api/test",
                    "protocol": "https",
                    "host": ["example", "com"],
                    "path": ["api", "test"]
                  }
                },
                "response": []
              },
              {
                "name": "Another Test Endpoint",
                "request": {
                  "method": "POST",
                  "url": {
                    "raw": "https://example.com/api/submit",
                    "protocol": "https",
                    "host": ["example", "com"],
                    "path": ["api", "submit"]
                  },
                  "body": {
                    "mode": "raw",
                    "raw": "{\n  \"key\": \"value\"\n}",
                    "options": { "raw": { "language": "json" } }
                  }
                },
                "response": []
              }
            ]
          }
          EOL
            echo "Created a sample collection with test endpoints"
          fi

      - name: Install Postman CLI
        run: |
          curl -sL https://dl-cli.pstmn.io/postman-cli/latest/linux64 -o postman
          chmod +x postman
          sudo mv postman /usr/local/bin/postman
          postman --version

      - name: Log in to Postman CLI
        run: postman login --with-api-key "${{ secrets.POSTMAN_API_KEY }}"

      - name: List Workspaces
        run: |
          echo "Available Workspaces:"
          postman workspace list
          
          # Verify the workspace ID exists
          postman workspace get --workspace "${{ secrets.POSTMAN_WORKSPACE_ID }}" || (echo "Workspace ID not found or not accessible" && exit 1)

      - name: List Collections before Push
        run: |
          echo "Collections in workspace before push:"
          postman collection list --workspace "${{ secrets.POSTMAN_WORKSPACE_ID }}"

      - name: Push Collection to Postman Workspace
        id: push_collection
        env:
          POSTMAN_WORKSPACE_ID: ${{ secrets.POSTMAN_WORKSPACE_ID }}
          POSTMAN_COLLECTION_UID: ${{ secrets.POSTMAN_COLLECTION_UID }}
          COLLECTION_FILE_PATH: ${{ steps.generate_collection.outputs.collection_file }}
          COLLECTION_NAME: "API Collection"
        run: |
          echo "Workspace ID: $POSTMAN_WORKSPACE_ID"
          echo "Collection File Path: $COLLECTION_FILE_PATH"
          echo "Collection Name: $COLLECTION_NAME"
          
          # Display the structure of the collection file before pushing
          echo "Collection file structure:"
          jq '.info.name, .item | length' "$COLLECTION_FILE_PATH"
          
          if [ -z "$POSTMAN_COLLECTION_UID" ] || [ "$POSTMAN_COLLECTION_UID" = "null" ]; then
            echo "Creating a new collection..."
            RESULT=$(postman collection create --file "$COLLECTION_FILE_PATH" --workspace "$POSTMAN_WORKSPACE_ID" --name "$COLLECTION_NAME")
            echo "Create Result: $RESULT"
            
            # Extract the collection UID from the result
            COLLECTION_UID=$(echo "$RESULT" | grep -oP 'Collection created with UID: \K[a-zA-Z0-9-]+' || echo "")
            echo "Created collection UID: $COLLECTION_UID"
            echo "collection_uid=$COLLECTION_UID" >> $GITHUB_OUTPUT
          else
            echo "Updating existing collection with UID: $POSTMAN_COLLECTION_UID"
            
            # Force create a new collection instead of updating
            # This is a temporary change for troubleshooting
            echo "Creating a new collection instead of updating..."
            NEW_COLLECTION_NAME="${COLLECTION_NAME}_$(date +%s)"
            RESULT=$(postman collection create --file "$COLLECTION_FILE_PATH" --workspace "$POSTMAN_WORKSPACE_ID" --name "$NEW_COLLECTION_NAME")
            echo "Create Result: $RESULT"
            
            # Original update code (commented out for now)
            # RESULT=$(postman collection update --uid "$POSTMAN_COLLECTION_UID" --file "$COLLECTION_FILE_PATH")
            # echo "Update Result: $RESULT"
            # echo "collection_uid=$POSTMAN_COLLECTION_UID" >> $GITHUB_OUTPUT
          fi

      - name: List Collections after Push
        run: |
          echo "Collections in workspace after push:"
          postman collection list --workspace "${{ secrets.POSTMAN_WORKSPACE_ID }}"

      - name: Upload Postman Collection as Artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: postman-collection
          path: ${{ steps.generate_collection.outputs.collection_file }}
          retention-days: 7